#include "crpropa/GridTools.h"
#include "crpropa/GridTurbulence.h"
#include "crpropa/Random.h"
#include "crpropa/magneticField/MagneticField.h"

#include <map>
#include <fstream>
#include <iomanip>
#include <vector>

#ifdef CRPROPA_HAVE_FFTW3
#include "fftw3.h"
#endif

// tmp
#include <iostream>

namespace crpropa {

double turbulentCorrelationLength(double lMin, double lMax, double alpha) {
	double r = lMin / lMax;
	double a = -alpha - 2;
	return lMax / 2 * (a - 1) / a * (1 - pow(r, a)) / (1 - pow(r, a - 1));
}

#ifdef CRPROPA_HAVE_FFTW3

VectorOfPairs gridPowerSpectrum(ref_ptr<VectorGrid> grid) {

	double rms = rmsFieldStrength(grid);
	size_t n = grid->getNx(); // size of array
	size_t n2 = (size_t) std::floor(n / 2) + 1; // size array in z-direction in configuration space
	Vector3d spacing = grid->getSpacing();

	// arrays to hold the complex vector components of the B(k)-field
	@FFTW_PREFIX@_complex *Bkx, *Bky, *Bkz;
	Bkx = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n);
	Bky = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n);
	Bkz = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n);

	@FFTW_PREFIX@_complex *Bx = (@FFTW_PREFIX@_complex*) Bkx;
	@FFTW_PREFIX@_complex *By = (@FFTW_PREFIX@_complex*) Bky;
	@FFTW_PREFIX@_complex *Bz = (@FFTW_PREFIX@_complex*) Bkz;

	// save to temp
	for (size_t ix = 0; ix < n; ix++) {
		for (size_t iy = 0; iy < n; iy++) {
			for (size_t iz = 0; iz < n; iz++) {
				size_t i = ix * n * n + iy * n + iz;
				Vector3<GridPrecision> &b = grid->get(ix, iy, iz);
				Bx[i][0] = b.x / (n*n*n);
				By[i][0] = b.y / (n*n*n);
				Bz[i][0] = b.z / (n*n*n);
			}
		}
	}

	// in-place, real to complex, inverse Fourier transformation on each component
	// note that the last elements of B(x) are unused now
	@FFTW_PREFIX@_plan plan_x = @FFTW_PREFIX@_plan_dft_3d(n, n, n, Bx, Bkx, FFTW_FORWARD, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_x);
	@FFTW_PREFIX@_destroy_plan(plan_x);

	@FFTW_PREFIX@_plan plan_y = @FFTW_PREFIX@_plan_dft_3d(n, n, n, By, Bky, FFTW_FORWARD, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_y);
	@FFTW_PREFIX@_destroy_plan(plan_y);

	@FFTW_PREFIX@_plan plan_z = @FFTW_PREFIX@_plan_dft_3d(n, n, n, Bz, Bkz, FFTW_FORWARD, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_z);
	@FFTW_PREFIX@_destroy_plan(plan_z);
	
	// calculate the n possible discrete wave numbers
	// k in [-n/2, n/2>
	double K[n];
	for (int i = 0; i < n; i++)
		K[i] = (static_cast<double>(i) - i / (n / 2) * n);

	// construct the field in configuration space
	double scaling = spacing.x * n / (2*M_PI);
	Vector3GridPrecision ek, e1, e2; // orthogonal base
	
	GridPrecision power;
	std::map<double, std::pair<GridPrecision, int> > spectrum;

	for (size_t ix = 0; ix < n; ix++) {
		for (size_t iy = 0; iy < n; iy++) {
			for (size_t iz = 0; iz < n; iz++) {
				
				size_t i = ix * n * n + iy * n + iz;
				ek.setXYZ(K[ix], K[iy], K[iz]);
				double k = ek.getR();
				
				if (k > n2 - 1 || k == 0)
					continue;

				// |\vec{B}(k)|^2
				power = ((Bkx[i][0]*Bkx[i][0] + Bkx[i][1]*Bkx[i][1]) +
					 (Bky[i][0]*Bky[i][0] + Bky[i][1]*Bky[i][1]) +
					 (Bkz[i][0]*Bkz[i][0] + Bkz[i][1]*Bkz[i][1]));
		
				double real_k = std::round(k) / scaling;	
				if (spectrum.find(real_k) == spectrum.end()) {
					spectrum[real_k].first = power;
					spectrum[real_k].second = 1;
				}
				else {
					spectrum[real_k].first += power;
					spectrum[real_k].second += 1;
				}
			}
		}
	}

	@FFTW_PREFIX@_free(Bkx);
	@FFTW_PREFIX@_free(Bky);
	@FFTW_PREFIX@_free(Bkz);

	VectorOfPairs points;
	for(std::map<double, std::pair<GridPrecision, int> >::iterator it = spectrum.begin(); it != spectrum.end(); ++it) {
        	points.push_back(std::make_pair(it->first, (it->second).first));
    	}

	return points;
}

/* Helper functions for synthetic turbulent field models */

// Check the grid properties before the FFT procedure
void checkGridRequirements(ref_ptr<VectorGrid> grid, double lMin, double lMax) {
	size_t Nx = grid->getNx();
	size_t Ny = grid->getNy();
	size_t Nz = grid->getNz();
	Vector3d spacing = grid->getSpacing();

	if ((Nx != Ny) or (Ny != Nz))
		throw std::runtime_error("turbulentField: only cubic grid supported");
	if ((spacing.x != spacing.y) or (spacing.y != spacing.z))
		throw std::runtime_error("turbulentField: only equal spacing suported");
	if (lMin < 2 * spacing.x)
		throw std::runtime_error("turbulentField: lMin < 2 * spacing");
	if (lMin >= lMax)
		throw std::runtime_error("turbulentField: lMin >= lMax");
	if (lMax > Nx * spacing.x) // before was (lMax > Nx * spacing.x / 2)
		throw std::runtime_error("turbulentField: lMax > size");
}

// Execute inverse discrete FFT in-place for a 3D grid, from complex to real space
void executeInverseFFTInplace(ref_ptr<VectorGrid> grid, @FFTW_PREFIX@_complex* Bkx, @FFTW_PREFIX@_complex* Bky, @FFTW_PREFIX@_complex* Bkz) {

	size_t n = grid->getNx(); // size of array
	size_t n2 = (size_t) floor(n / 2) + 1; // size array in z-direction in configuration space

	// in-place, complex to real, inverse Fourier transformation on each component
	// note that the last elements of B(x) are unused now
	GridPrecision *Bx = (GridPrecision*) Bkx;
	@FFTW_PREFIX@_plan plan_x = @FFTW_PREFIX@_plan_dft_c2r_3d(n, n, n, Bkx, Bx, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_x);
	@FFTW_PREFIX@_destroy_plan(plan_x);

	GridPrecision *By = (GridPrecision*) Bky;
	@FFTW_PREFIX@_plan plan_y = @FFTW_PREFIX@_plan_dft_c2r_3d(n, n, n, Bky, By, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_y);
	@FFTW_PREFIX@_destroy_plan(plan_y);

	GridPrecision *Bz = (GridPrecision*) Bkz;
	@FFTW_PREFIX@_plan plan_z = @FFTW_PREFIX@_plan_dft_c2r_3d(n, n, n, Bkz, Bz, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_z);
	@FFTW_PREFIX@_destroy_plan(plan_z);

	// save to grid
	for (size_t ix = 0; ix < n; ix++) {
		for (size_t iy = 0; iy < n; iy++) {
			for (size_t iz = 0; iz < n; iz++) {
				size_t i = ix * n * 2 * n2 + iy * 2 * n2 + iz;
				Vector3GridPrecision &b = grid->get(ix, iy, iz);
				b.x = Bx[i];
				b.y = By[i];
				b.z = Bz[i];
			}
		}
	}
}

void initTurbulence(ref_ptr<VectorGrid> grid, double Brms, double lMin, double lMax, double alpha, int seed) {

	checkGridRequirements(grid, lMin, lMax);

	Vector3d spacing = grid->getSpacing();
	size_t n = grid->getNx(); // size of array
	size_t n2 = (size_t) floor(n / 2) + 1; // size array in z-direction in configuration space

	// arrays to hold the complex vector components of the B(k)-field
	@FFTW_PREFIX@_complex *Bkx, *Bky, *Bkz;
	Bkx = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);
	Bky = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);
	Bkz = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);

	Random random;
	if (seed != 0)
		random.seed(seed); // use given seed

	// construct the field in configuration space
	// calculate the n possible discrete wave numbers
	double K[n];
	for (int i = 0; i < n; i++)
		K[i] = (double) i / n - i / (n / 2);

	// parameters goes for non-helical calculations
	double theta, phase, cosPhase, sinPhase;

	double kMin = spacing.x / lMax;
	double kMax = spacing.x / lMin;
	Vector3GridPrecision b; // real b-field vector
	Vector3GridPrecision ek, e1, e2; // orthogonal base
	Vector3GridPrecision n0(1, 1, 1); // arbitrary vector to construct orthogonal base

	for (size_t ix = 0; ix < n; ix++) {
		for (size_t iy = 0; iy < n; iy++) {
			for (size_t iz = 0; iz < n2; iz++) {

				size_t i = ix * n * n2 + iy * n2 + iz;
				ek.setXYZ(K[ix], K[iy], K[iz]);
				double k = ek.getR();

				// wave outside of turbulent range -> B(k) = 0
				if ((k < kMin) || (k > kMax)) {
					Bkx[i][0] = 0;
					Bkx[i][1] = 0;
					Bky[i][0] = 0;
					Bky[i][1] = 0;
					Bkz[i][0] = 0;
					Bkz[i][1] = 0;
					continue;
				}

				// construct an orthogonal base ek, e1, e2
				if (ek.isParallelTo(n0, float(1e-3))) {
					// ek parallel to (1,1,1)
					e1.setXYZ(-1., 1., 0);
					e2.setXYZ(1., 1., -2.);
				} else {
					// ek not parallel to (1,1,1)
					e1 = n0.cross(ek);
					e2 = ek.cross(e1);
				}
				e1 /= e1.getR();
				e2 /= e2.getR();

				// random orientation perpendicular to k
				theta = 2 * M_PI * random.rand();
				b = e1 * cos(theta) + e2 * sin(theta);

				// normal distributed amplitude with mean = 0 and sigma = k^alpha/2
				b *= random.randNorm() * pow(k, alpha / 2);

				// uniform random phase
				phase = 2 * M_PI * random.rand();
				cosPhase = cos(phase); // real part
				sinPhase = sin(phase); // imaginary part

				Bkx[i][0] = b.x * cosPhase;
				Bkx[i][1] = b.x * sinPhase;
				Bky[i][0] = b.y * cosPhase;
				Bky[i][1] = b.y * sinPhase;
				Bkz[i][0] = b.z * cosPhase;
				Bkz[i][1] = b.z * sinPhase;
			} // for iz
		} // for iy
	} // for ix

	executeInverseFFTInplace(grid, Bkx, Bky, Bkz);

	@FFTW_PREFIX@_free(Bkx);
	@FFTW_PREFIX@_free(Bky);
	@FFTW_PREFIX@_free(Bkz);

	scaleGrid(grid, Brms / rmsFieldStrength(grid)); // normalize to Brms
}

void initHelicalTurbulence(ref_ptr<VectorGrid> grid, double Brms, double lMin, double lMax, double alpha, int seed, double H) {

	checkGridRequirements(grid, lMin, lMax);

	Vector3d spacing = grid->getSpacing();
	size_t n = grid->getNx(); // size of array
	size_t n2 = (size_t) floor(n / 2) + 1; // size array in z-direction in configuration space

	// arrays to hold the complex vector components of the B(k)-field
	@FFTW_PREFIX@_complex *Bkx, *Bky, *Bkz;
	Bkx = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);
	Bky = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);
	Bkz = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);

	Random random;
	if (seed != 0)
		random.seed(seed); // use given seed

	// construct the field in configuration space
	// calculate the n possible discrete wave numbers
	double K[n];
	for (int i = 0; i < n; i++)
		K[i] = (double) i / n - i / (n / 2);

	// only used if there is a helicity
	double Bktot, Bkplus, Bkminus, thetaplus, thetaminus;

	double kMin = spacing.x / lMax;
	double kMax = spacing.x / lMin;
	Vector3d b; // real b-field vector
	Vector3d ek, e1, e2; // orthogonal base
	Vector3d n0(1, 1, 1); // arbitrary vector to construct orthogonal base

	for (size_t ix = 0; ix < n; ix++) {
		for (size_t iy = 0; iy < n; iy++) {
			for (size_t iz = 0; iz < n2; iz++) {
				
				size_t i = ix * n * n2 + iy * n2 + iz;
				ek.setXYZ(K[ix], K[iy], K[iz]);
				double k = ek.getR();

				// wave outside of turbulent range -> B(k) = 0
				if ((k < kMin) || (k > kMax)) {
					Bkx[i][0] = 0;
					Bkx[i][1] = 0;
					Bky[i][0] = 0;
					Bky[i][1] = 0;
					Bkz[i][0] = 0;
					Bkz[i][1] = 0;
					continue;
				}

				// construct an orthogonal base ek, e1, e2
				// (for helical fields together with the real transform the following convention
				// must be used: e1(-k) = e1(k), e2(-k) = - e2(k)
				if (ek.getAngleTo(n0) < 1e-3) { // ek parallel to (1,1,1)
					e1.setXYZ(-1, 1, 0);
					e2.setXYZ(1, 1, -2);
				} else { // ek not parallel to (1,1,1)
					e1 = n0.cross(ek);
					e2 = ek.cross(e1);
				}
				e1 /= e1.getR();
				e2 /= e2.getR();


				double Bkprefactor = mu0 / (4 * M_PI * pow(k, 3));
				Bktot = fabs(random.randNorm() * pow(k, alpha / 2));
				Bkplus  = Bkprefactor * sqrt((1 + H) / 2) * Bktot;
				Bkminus = Bkprefactor * sqrt((1 - H) / 2) * Bktot;
				thetaplus = 2 * M_PI * random.rand();
				thetaminus = 2 * M_PI * random.rand();
				double ctp = cos(thetaplus);
				double stp = sin(thetaplus);
				double ctm = cos(thetaminus);
				double stm = sin(thetaminus);

				Bkx[i][0] = ((Bkplus * ctp + Bkminus * ctm) * e1.x + (-Bkplus * stp + Bkminus * stm) * e2.x) / sqrt(2);
				Bkx[i][1] = ((Bkplus * stp + Bkminus * stm) * e1.x + ( Bkplus * ctp - Bkminus * ctm) * e2.x) / sqrt(2);
				Bky[i][0] = ((Bkplus * ctp + Bkminus * ctm) * e1.y + (-Bkplus * stp + Bkminus * stm) * e2.y) / sqrt(2);
				Bky[i][1] = ((Bkplus * stp + Bkminus * stm) * e1.y + ( Bkplus * ctp - Bkminus * ctm) * e2.y) / sqrt(2);
				Bkz[i][0] = ((Bkplus * ctp + Bkminus * ctm) * e1.z + (-Bkplus * stp + Bkminus * stm) * e2.z) / sqrt(2);
				Bkz[i][1] = ((Bkplus * stp + Bkminus * stm) * e1.z + ( Bkplus * ctp - Bkminus * ctm) * e2.z) / sqrt(2);

				Vector3d BkRe(Bkx[i][0], Bky[i][0], Bkz[i][0]);
				Vector3d BkIm(Bkx[i][1], Bky[i][1], Bkz[i][1]);
			} // for iz
		} // for iy
	} // for ix

	executeInverseFFTInplace(grid, Bkx, Bky, Bkz);

	scaleGrid(grid, Brms / rmsFieldStrength(grid)); // normalize to Brms
}

void initTurbulenceWithBendover(ref_ptr<VectorGrid> grid, double Brms, double lMin, double lMax, double alpha, int seed, double lambda) {

	checkGridRequirements(grid, lMin, lMax);

	Vector3d spacing = grid->getSpacing();
	size_t n = grid->getNx(); // size of array
	size_t n2 = (size_t) std::floor(n / 2) + 1; // size array in z-direction in configuration space

	// arrays to hold the complex vector components of the B(k)-field
	@FFTW_PREFIX@_complex *Bkx, *Bky, *Bkz;
	Bkx = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);
	Bky = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);
	Bkz = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n * n2);

	Random random;
	if (seed != 0)
		random.seed(seed); // use given seed

	// calculate the n possible discrete wave numbers
	// k in [-n/2, n/2>
	double K[n];
	for (int i = 0; i < n; i++)
		K[i] = (static_cast<double>(i) - i / (n / 2) * n);

	// construct the field in configuration space
	double scaling = spacing.x * n / (2*M_PI);

	// parameters goes for non-helical calculations
	double theta, phase, cosPhase, sinPhase;

	double kMin = 2*M_PI / lMax * scaling;
	double kMax = 2*M_PI / lMin * scaling;
	lambda = lambda / scaling;

	Vector3d b; // real b-field vector
	Vector3d ek, e1, e2; // orthogonal base
	Vector3d n0(1, 1, 1); // arbitrary vector to construct orthogonal base
	// dot product can produce ~1e-7 for orthogonal Vector3f vectors

	GridPrecision power;
	std::map<double, std::pair<GridPrecision, int> > spectrum;

	for (size_t ix = 0; ix < n; ix++) {
		for (size_t iy = 0; iy < n; iy++) {
			for (size_t iz = 0; iz < n2; iz++) {

				size_t i = ix * n * n2 + iy * n2 + iz;
				ek.setXYZ(K[ix], K[iy], K[iz]);
				double k = ek.getR();

				// wave outside of turbulent range -> B(k) = 0
				if ((k < kMin) || (k > kMax)) {
					Bkx[i][0] = 0;
					Bkx[i][1] = 0;
					Bky[i][0] = 0;
					Bky[i][1] = 0;
					Bkz[i][0] = 0;
					Bkz[i][1] = 0;
					continue;
				}

				// construct an orthogonal base ek, e1, e2
				if (ek.isParallelTo(n0, double(1e-3))) {
					// ek parallel to (1,1,1)
					e1.setXYZ(-1., 1., 0);
					e2.setXYZ(-1., -1., 2.);
				} else {
					// ek not parallel to (1,1,1)
					e1 = n0.cross(ek);
					e2 = ek.cross(e1);
				}
				e1 /= e1.getR();
				e2 /= e2.getR();

				// random orientation perpendicular to k
				theta = 2 * M_PI * random.rand();
				b = e1 * cos(theta) + e2 * sin(theta);

				// normal distributed amplitude with mean = 0 and sigma = k^alpha/2
				b *= k * lambda *
					std::pow(1.0 + k*k*lambda*lambda, (alpha / 2. - 1.) / 2.);

				// uniform random phase
				phase = 2 * M_PI * random.rand();
				cosPhase = cos(phase); // real part
				sinPhase = sin(phase); // imaginary part

				Bkx[i][0] = b.x * cosPhase;
				Bkx[i][1] = b.x * sinPhase;
				Bky[i][0] = b.y * cosPhase;
				Bky[i][1] = b.y * sinPhase;
				Bkz[i][0] = b.z * cosPhase;
				Bkz[i][1] = b.z * sinPhase;
			} // for iz
		} // for iy
	} // for ix

	executeInverseFFTInplace(grid, Bkx, Bky, Bkz);

	@FFTW_PREFIX@_free(Bkx);
	@FFTW_PREFIX@_free(Bky);
	@FFTW_PREFIX@_free(Bkz);
	
	scaleGrid(grid, Brms / rmsFieldStrength(grid)); // normalize to Brms
}

void initSlabTurbulence(ref_ptr<VectorGrid> grid, double Brms, double lMin, double lMax, double alpha, int seed, double lambda) {

	Vector3d spacing = grid->getSpacing();
	size_t nx = grid->getNx(); // size of array in X-dir
	size_t ny = grid->getNy(); // size of array in Y-dir
	size_t nz = grid->getNz(); // size of array in Z-dir
	size_t n2 = (size_t) std::floor(nz / 2) + 1; // size array in z-direction in configuration space

	// arrays to hold the complex vector components of the B(k)-field
	@FFTW_PREFIX@_complex *Bkx, *Bky;
	Bkx = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * nz);
	Bky = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * nz);

	Random random;
	if (seed != 0)
		random.seed(seed); // use given seed
	
	// calculate the n possible discrete wave numbers
	// k in [-n/2, n/2>
	std::unique_ptr<std::vector<double>> K(new std::vector<double>);
	K->reserve(nz);
	for (size_t i = 0; i < nz; i++)
		K->push_back(static_cast<double>(i) - i / (nz / 2) * nz);
	
	// construct the field in configuration space
	double scaling = spacing.z * nz / (2*M_PI);

	// parameters goes for non-helical calculations
	double theta, phase, cosPhase, sinPhase;

	double kMin = 2*M_PI / lMax * scaling;
	double kMax = 2*M_PI / lMin * scaling;
	lambda = lambda / scaling;

	Vector3d b; // real b-field vector
	Vector3d ek, e1, e2; // orthogonal base
	Vector3d n0(1, 1, 1); // arbitrary vector to construct orthogonal base
	// dot product can produce ~1e-7 for orthogonal Vector3f vectors

	for (size_t iz = 0; iz < nz; iz++) {
		ek.setXYZ(0, 0, (*K)[iz]);
		double k = ek.getR();

		// wave outside of turbulent range -> B(k) = 0
		if ((k < kMin) || (k > kMax)) {
			Bkx[iz][0] = 0;
			Bkx[iz][1] = 0;
			Bky[iz][0] = 0;
			Bky[iz][1] = 0;
			continue;
		}

		// construct an orthogonal base ek, e1, e2
		if (ek.isParallelTo(n0, double(1e-3))) {
			// ek parallel to (1,1,1)
			e1.setXYZ(-1., 1., 0);
			e2.setXYZ(-1., -1., 2.);
		} else {
			// ek not parallel to (1,1,1)
			e1 = n0.cross(ek);
			e2 = ek.cross(e1);
		}
		e1 /= e1.getR();
		e2 /= e2.getR();

		// random orientation perpendicular to k
		theta = 2 * M_PI * random.rand();
		b = e1 * cos(theta) + e2 * sin(theta);

		// normal distributed amplitude with mean = 0 and sigma = k^(-nu)/2
		//b *= k * lambda *
		//	std::pow(1.0 + k*k*lambda*lambda, alpha / 4.);
		b *= std::pow(1.0 + k*k*lambda*lambda, alpha / 4. + 1/2.);

		// uniform random phase
		phase = 2 * M_PI * random.rand();
		cosPhase = cos(phase); // real part
		sinPhase = sin(phase); // imaginary part

		Bkx[iz][0] = b.x * cosPhase;
		Bkx[iz][1] = b.x * sinPhase;
		Bky[iz][0] = b.y * cosPhase;
		Bky[iz][1] = b.y * sinPhase;
	} // for iz

	// in-place, complex to real, inverse Fourier transformation on each component
	// note that the last elements of B(x) are unused now
	GridPrecision *Bx = (GridPrecision*) Bkx;
	@FFTW_PREFIX@_plan plan_x = @FFTW_PREFIX@_plan_dft_c2r_1d(nz, Bkx, Bx, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_x);
	@FFTW_PREFIX@_destroy_plan(plan_x);

	GridPrecision *By = (GridPrecision*) Bky;
	@FFTW_PREFIX@_plan plan_y = @FFTW_PREFIX@_plan_dft_c2r_1d(nz, Bky, By, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_y);
	@FFTW_PREFIX@_destroy_plan(plan_y);

	// save to grid
	for (size_t ix = 0; ix < nx; ix++) {
		for (size_t iy = 0; iy < ny; iy++) {
			for (size_t iz = 0; iz < nz; iz++) {
				Vector3GridPrecision &b = grid->get(ix, iy, iz);
				b.x = Bx[iz];
				b.y = By[iz];
				b.z = 0;
			}
		}
	}

	@FFTW_PREFIX@_free(Bkx);
	@FFTW_PREFIX@_free(Bky);
	
	scaleGrid(grid, Brms / rmsFieldStrength(grid)); // normalize to Brms
}

void init2DTurbulence(ref_ptr<VectorGrid> grid, double Brms, double lMin, double lMax, double alpha, int seed, double lambda) {

	Vector3d spacing = grid->getSpacing();
	size_t nx = grid->getNx(); // size of array in X-dir
	size_t ny = grid->getNy(); // size of array in Y-dir
	size_t nz = grid->getNz(); // size of array in Z-dir
	size_t n  = nx;
	size_t n2 = (size_t) std::floor(nx / 2) + 1; // size array in z-direction in configuration space

	// arrays to hold the complex vector components of the B(k)-field
	@FFTW_PREFIX@_complex *Bkx, *Bky;
	Bkx = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n);
	Bky = (@FFTW_PREFIX@_complex*) @FFTW_PREFIX@_malloc(sizeof(@FFTW_PREFIX@_complex) * n * n);

	Random random;
	if (seed != 0)
		random.seed(seed); // use given seed

	// calculate the n possible discrete wave numbers
	// k in [-n/2, n/2>
	std::unique_ptr<std::vector<double>> K(new std::vector<double>);
	K->reserve(nz);
	for (size_t i = 0; i < n; i++)
		K->push_back(static_cast<double>(i) - i / (n / 2) * n);

	// construct the field in configuration space
	double scaling = spacing.x * nx / (2*M_PI);

	// parameters goes for non-helical calculations
	double theta, phase, cosPhase, sinPhase;

	double kMin = 2*M_PI / lMax * scaling;
	double kMax = 2*M_PI / lMin * scaling;
	lambda = lambda / scaling;

	Vector3d b; // real b-field vector
	Vector3d ek, e1, e2; // orthogonal base
	Vector3d n0(1, 1, 1); // arbitrary vector to construct orthogonal base
	// dot product can produce ~1e-7 for orthogonal Vector3f vectors

	for (size_t ix = 0; ix < nx; ix++) {
		for (size_t iy = 0; iy < ny; iy++) {
				
			size_t i = ix * nx + iy;
			ek.setXYZ((*K)[ix], (*K)[iy], 0);
			double k = ek.getR();
	
			// wave outside of turbulent range -> B(k) = 0
			if ((k < kMin) || (k > kMax)) {
				Bkx[i][0] = 0;
				Bkx[i][1] = 0;
				Bky[i][0] = 0;
				Bky[i][1] = 0;
				continue;
			}

			// construct an orthogonal base ek, e1, e2
			if (ek.isParallelTo(n0, double(1e-3))) {
				// ek parallel to (1,1,1)
				e1.setXYZ(-1., 1., 0);
				e2.setXYZ(-1., -1., 2.);
			} else {
				// ek not parallel to (1,1,1)
				e1 = n0.cross(ek);
				e2 = ek.cross(e1);
			}
			e1 /= e1.getR();
			e2 /= e2.getR();

			// random orientation perpendicular to k
			theta = 2 * M_PI * random.rand();
			b = e1 * cos(theta) + e2 * sin(theta);

			// normal distributed amplitude with mean = 0 and sigma = k^(-nu)/2
			b *= k * lambda *
				std::pow(1.0 + k*k*lambda*lambda, alpha / 4.);

			// uniform random phase
			phase = 2 * M_PI * random.rand();
			cosPhase = cos(phase); // real part
			sinPhase = sin(phase); // imaginary part

			Bkx[i][0] = b.x * cosPhase;
			Bkx[i][1] = b.x * sinPhase;
			Bky[i][0] = b.y * cosPhase;
			Bky[i][1] = b.y * sinPhase;
		} // for iy
	} // for ix
	
	// in-place, complex to real, inverse Fourier transformation on each component
	// note that the last elements of B(x) are unused now
	GridPrecision *Bx = (GridPrecision*) Bkx;
	@FFTW_PREFIX@_plan plan_x = @FFTW_PREFIX@_plan_dft_c2r_2d(nx, ny, Bkx, Bx, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_x);
	@FFTW_PREFIX@_destroy_plan(plan_x);

	GridPrecision *By = (GridPrecision*) Bky;
	@FFTW_PREFIX@_plan plan_y = @FFTW_PREFIX@_plan_dft_c2r_2d(nx, ny, Bky, By, FFTW_ESTIMATE);
	@FFTW_PREFIX@_execute(plan_y);
	@FFTW_PREFIX@_destroy_plan(plan_y);
			
	// save to grid
	for (size_t ix = 0; ix < nx; ix++) {
		for (size_t iy = 0; iy < ny; iy++) {
			for (size_t iz = 0; iz < nz; iz++) {
				size_t i = ix * n + iy * n;
				Vector3GridPrecision &b = grid->get(ix, iy, iz);
				b.x = Bx[i];
				b.y = By[i];
				b.z = 0;
			}
		}
	}
	
	@FFTW_PREFIX@_free(Bkx);
	@FFTW_PREFIX@_free(Bky);
	
	scaleGrid(grid, Brms / rmsFieldStrength(grid)); // normalize to Brms
}

#endif // CRPROPA_HAVE_FFTW3

} // namespace crpropa
